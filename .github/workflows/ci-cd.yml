name: deploy
on:
  push:
    branches: [main]          # deploy on main
  workflow_dispatch:          # allow manual runs

# Prevent overlapping deploys on main
concurrency:
  group: deploy-main
  cancel-in-progress: false

permissions:
  contents: read              # no OIDC needed when using keys

env:
  AWS_REGION: ap-south-1
  TF_DIR: infra/envs/prod
  APP_DIR: app
  # âœ… Provide TF variables so Terraform never prompts:
  TF_VAR_github_repo: JATINKUMAR1008/Blue-green-deployemnt
  TF_VAR_image_tag: init

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      # ðŸ” Configure AWS using access keys stored as repo secrets
      - name: Configure AWS (access keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.AWS_SESSION_TOKEN }} # optional
          aws-region:            ${{ env.AWS_REGION }}

      - name: Who am I? (verify keys)
        run: aws sts get-caller-identity

      - name: Install tooling (jq)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Derive metadata
        id: meta
        run: echo "sha=${GITHUB_SHA::12}" >> "$GITHUB_OUTPUT"

      # âœ… Ensure infra exists on first run; skip apply once state is present
      - name: Ensure infra exists (apply only if no state)
        run: |
          set -euo pipefail
          TF_DIR="${{ env.TF_DIR }}"
          terraform -chdir="$TF_DIR" init -input=false
          if ! terraform -chdir="$TF_DIR" state list >/dev/null 2>&1; then
            echo "No state found â€” bootstrapping infraâ€¦"
            terraform -chdir="$TF_DIR" apply -auto-approve -input=false
          else
            echo "State exists â€” skipping infra apply."
          fi

      - name: Read Terraform outputs
        id: tf
        run: |
          terraform -chdir=${{ env.TF_DIR }} refresh -lock=false || true
          echo "alb=$(terraform -chdir=${{ env.TF_DIR }} output -raw alb_dns)" >> $GITHUB_OUTPUT
          echo "ecr=$(terraform -chdir=${{ env.TF_DIR }} output -raw ecr_repo)" >> $GITHUB_OUTPUT
          echo "cluster=$(terraform -chdir=${{ env.TF_DIR }} output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "service=$(terraform -chdir=${{ env.TF_DIR }} output -raw service_name)" >> $GITHUB_OUTPUT
          echo "family=$(terraform -chdir=${{ env.TF_DIR }} output -raw task_family)" >> $GITHUB_OUTPUT
          echo "cd_app=$(terraform -chdir=${{ env.TF_DIR }} output -raw cd_app)" >> $GITHUB_OUTPUT
          echo "cd_group=$(terraform -chdir=${{ env.TF_DIR }} output -raw cd_group)" >> $GITHUB_OUTPUT

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push image
        working-directory: ${{ env.APP_DIR }}
        run: |
          set -euo pipefail
          IMAGE="${{ steps.tf.outputs.ecr }}"
          TAG="${{ steps.meta.outputs.sha }}"
          docker build -t "$IMAGE:$TAG" .
          docker push "$IMAGE:$TAG"

      # âœ… Safer: fetch latest ACTIVE TD by family, then register with new image
      - name: Register new ECS task definition
        id: taskdef
        run: |
          set -euo pipefail
          FAMILY="${{ steps.tf.outputs.family }}"
          NEW_IMAGE="${{ steps.tf.outputs.ecr }}:${{ steps.meta.outputs.sha }}"

          # Get latest ACTIVE task definition using the FAMILY name
          if ! aws ecs describe-task-definition --task-definition "$FAMILY" \
              --query 'taskDefinition' > base.json 2>/dev/null; then
            echo "Could not find a task definition by family '$FAMILY'." >&2
            echo "Ensure Terraform created the initial TD successfully." >&2
            exit 1
          fi

          # Swap image + inject version/env on the 'app' container
          jq --arg img "$NEW_IMAGE" \
             'del(.taskDefinitionArn,.revision,.status,.compatibilities,.requiresAttributes,.registeredAt,.registeredBy)
              | .containerDefinitions = (.containerDefinitions | map(
                  if .name=="app" then
                    (.image=$img | .environment = [
                      {"name":"APP_VERSION","value":"'"${{ steps.meta.outputs.sha }}"'"},
                      {"name":"APP_ENV","value":"prod"},
                      {"name":"GIT_SHA","value":"'"${{ steps.meta.outputs.sha }}"'"}
                    ])
                  else . end
                ))' base.json > new.json

          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "arn=$NEW_TD_ARN" >> "$GITHUB_OUTPUT"

      - name: Create CodeDeploy blue/green deployment
        id: deploy
        run: |
          set -euo pipefail
          APP="${{ steps.tf.outputs.cd_app }}"
          GROUP="${{ steps.tf.outputs.cd_group }}"
          TD="${{ steps.taskdef.outputs.arn }}"

          # Determine container port from the task definition we just registered
          PORT=$(jq -r '.containerDefinitions[] | select(.name=="app") | .portMappings[0].containerPort' new.json)

          # Build AppSpec for ECS deployment
          cat > appspec.json <<EOF
          {
            "version": 1,
            "Resources": [
              {
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": "${TD}",
                    "LoadBalancerInfo": {
                      "ContainerName": "app",
                      "ContainerPort": ${PORT}
                    }
                  }
                }
              }
            ]
          }
          EOF

          # Wrap AppSpec in the revision structure expected by CodeDeploy
          jq -n --arg content "$(cat appspec.json)" '{revisionType:"AppSpecContent", appSpecContent:{content:$content}}' > revision.json

          DEPLOY_ID=$(aws deploy create-deployment \
            --application-name "$APP" \
            --deployment-group-name "$GROUP" \
            --deployment-config-name CodeDeployDefault.ECSAllAtOnce \
            --revision file://revision.json \
            --query deploymentId --output text)
          echo "id=$DEPLOY_ID" >> $GITHUB_OUTPUT

      - name: Wait for deployment to succeed (auto-rollback on alarm/failure)
        run: aws deploy wait deployment-successful --deployment-id "${{ steps.deploy.outputs.id }}"

      - name: Smoke test ALB
        run: |
          set -euo pipefail
          URL="http://${{ steps.tf.outputs.alb }}"
          curl -fsS "$URL/healthz/live" >/dev/null
          curl -fsS "$URL/" | grep -q '"status":"ok"'

      - name: Summary
        run: |
          echo "âœ… Deployed commit ${{ steps.meta.outputs.sha }} to service: ${{ steps.tf.outputs.service }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ ALB:  http://${{ steps.tf.outputs.alb }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ Image: ${{ steps.tf.outputs.ecr }}:${{ steps.meta.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸš€ CodeDeploy ID: ${{ steps.deploy.outputs.id }}" >> $GITHUB_STEP_SUMMARY
